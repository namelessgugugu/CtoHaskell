## CtoHaskell

从 C 语言到 Haskell 语言的转换器，基于大语言模型。

## 辅助模块

`loader.py`：提供读取文件的接口。

```python
def load_config(path):
    """
    Load configuration file with given path.

    Parameters:
        path - path of file (e.g. "../config/general.json" and "../config/secret.json").
    
    Returns:
        A dictionary representing the json file.
    
    Raises:
        FileNotFoundError - File not found.
        InvalidJsonError - File doesn't fit json format.
    """
    ...

def load_prompt(path):
    """
    Load prompt text file with given path.

    Parameters:
        path - path of file (e.g. "../prompt/translator")
    
    Returns:
        A string read from file.
    
    Raises:
        FileNotFoundError - File not found.
    """
    ...
```

例如要在 `src/xxx.py` 里读取 `config/general.json`，应调用 `load_config(Path(__file__).parent / "../config/general.json")`。

## 暂定框架

下文中用到的的各类路径和 Api key 都应取自 `config/general.json` 和 `config/secret.json`。

`assistant.py`：提供与 LLM 对话的接口。

```python
class Assistant:
    def __init__(self, api_key, model, temperature, retry_limit):
        """
        Create a llm assistant with given model and temperature.

        Parameters:
            api_key - Api key of SiliconFlow.
            model - name of the model to be called.
            temperature - temperature set by the model.
            retry_limit - maximum number of retries if network error occurs.
        """
        ...
    
    def chat(self, messages):
        """
        Generate a response of given context.

        Parameters:
            messages - a list of previous conversation. Each message
                should follow the format { "role": "user" / "assistant",
                "content": <content>}.
        
        Returns:
            Response generated by llm.

        Raises:
            ApiError(code) - response has an unsuccessful status code, after
                retry_limit retries.
        """
        ...
```

`checker.py`：接入 GCC 与 GHC，做语法检查。

```python
class CChecker:
    def __init__(self, gcc_path):
        """
        Create a C syntax checker.

        Parameters:
            gcc_path - path of gcc.
        """
        ...

    def check(self, code):
        """
        Check whether code is grammatically correct.

        Parameters:
            code - C code.
        
        Returns:
            If code passes the check, None is returned,
            otherwise CGrammarError(error_message) is **returned**, not raised.
        """
        ...

class HaskellGrammarError(ValueError):
    def __init__(self, error_message):
        self.error_message = error_message

class HaskellChecker:
    def __init__(self, ghc_path):
        """
        Create a Haskell syntax checker.

        Parameters:
            ghc_path - path of ghc.
        """
        ...

    def check(self, code):
        """
        Check whether code is grammatically correct.

        Parameters:
            code - Haskell code.
        
        Returns:
            If code passes the check, None is returned,
            otherwise HaskellGrammarError(error_message) is **returned**, not raised.
        """
        ...
```

`preprocessor.py`：预处理 C 代码，提取全局变量。

```python
class Preprocessor:
    def __init__(self, gcc_path, fake_libc_path):
        """
        Create preprocessor of C code.

        Parameters:
            gcc_path - path of gcc.
            fake_libc_path - path of fake_libc_include, used by pycparser.
        """
        ...

    def preprocess(self, code):
        """
        Preprocess C code to split global varibles and other function.

        Parameters:
            code - C code to be preprocessed.

        Returns:
            head_files - a list of head file included by code.
            global_varibles - a list of global varible declarations in code.
            other - other part of the code.
        
        Raises:
            CGrammarError - code is not a valid C code.
            ParseError - code cannot be parsed by pycparser.
        """
        ...
```

`translator.py`：将 C 代码翻译到 Haskell 代码。

```python
class Translator:
    def __init__(
            self,
            assistant,
            gcc_path,
            fake_libc_path,
            ghc_path,
            system_prompt,
            retry_limit
        ):
        """
        Create a translator with given assistant.

        Parameters:
            assistant - an Assistant from assistant.py.
            gcc_path - path of gcc.
            fake_libc_path - path of fake_libc_include.
            ghc_path - path of ghc.
            system_prompt - prompt to guide llm.
            retry_limit - maximum number of retries if llm generates
                grammatically wrong code.
        """
        ...
    
    def translate(self, code):
        """
        Translate C code to Haskell.

        Parameters:
            code - C code to be translated.
        
        Returns:
            Haskell code.
        
        Raises:
            ApiError(code) - response has an unsuccessful status code, after
                assistant._retry_limit retries.
            CGrammarError - code is not a valid C code.
            ParseError - code cannot be parsed by pycparser.
            TranslateError - llm generates grammatically wrong code,
                after retry_limit retries.
        """
        ...
```

`optimizer.py`：对 Haskell 代码进行优化。

```python
class Optimizer:
    def __init__(self, assistant, ghc_path, system_prompt, retry_limit):
        """
        Create a Optimizer with given assistant.

        Parameters:
            assistant - an Assistant from assistant.py.
            ghc_path - path of ghc.
            system_prompt - prompt to guide llm.
            retry_limit - maximum number of retries if llm generates
                grammatically wrong code.
        """
        ...
    
    def optimize(self, code):
        """
        Optimize Haskell code.

        Parameters:
            code - Haskell code to be optimized.
        
        Returns:
            Optimized code.
        
        Raises:
            HaskellGrammarError - code is not valid haskell code.
            OptimizeError - llm generates grammatically wrong code,
                after retry_limit retries.
        """
        ...
```

`verifier.py`：对 C 代码和 Haskell 代码进行对比。

```python
class Verifier:
    def __init__(self, assistant, gcc_path, ghc_path, system_prompt, retry_limit):
        """
        Create a Verifiers with given assistant.

        Parameters:
            assistant - an Assistant from assistant.py.
            retry_limit - maximum number of retries if llm generates
                grammatically wrong code.
        """
        ...
    
    def verify(self, c_code, haskell_code):
        """
        Verify whether c_code and haskell_code are the same.

        Parameters:
            c_code - C code.
            haskell_code - Haskell code.
        
        Returns:
            Modified haskell code, which equals to original haskell_code
            if it's correct.
        
        Raises:
            ApiError(code) - response has an unsuccessful status code, after
                assistant._retry_limit retries.
            CGrammarError - c_code is not a valid C code.
            HaskellGrammarError - haskell_code is not a valid C code.
            VerifyError - llm generates grammatically wrong code,
                after retry_limit retries.
        """
        ...
```

`ui.py`：用户界面。

`main.py`：将 C 语言代码转到 Haskell 完成后的代码。

```python
class CtoHaskell:
    def __init__(self):
            """
            Preprocess all required modules.
            """
    def run(self, input_code):
            """
            Translate C to Haskell.

            Parameters:
                input_code - C code to be translated.

            Returns:
                Haskell code.
            """
```



## 备注

### 测试

使用 `pytest` 进行单元测试，该模块需用 `conda install pytest` 下载。

用法为在 `tests` 文件夹下创建以 `test_` 开头的文件，编写以 `test_` 开头的函数，一般每个源代码模块对应一个测试文件。

如有需要，测试数据可放在 `tests/data` 下。

测试函数不需要输入参数与返回值，以是否不抛出异常作为是否通过的标准。

如欲测试某代码是否正确抛出异常，则用 `with pytest.raises(xxxError):` 包裹，表示该部分代码应抛出错误 `xxxError`。

在项目根目录运行 `python -m pytest` 以运行所有测试样例，运行 `python -m pytest -vs tests/test_xxx.py` 运行指定的 `test_xxx.py` 模块。